Yet another MIPS processor simulator.

DESCRIPTION:
This simulator runs a subset of the little endian MIPS32 (MIPSEL)
specification.  Full compliance to the specification is a non-goal, in
fact it only implements enough instructions to run the examples. It does
not implement caches and any type of memory management. It does not have a
delay slot. It does not implements interruptions of any kind.

To build the simulator:
	- Build dependencies: c99 compiler, POSIX compatible libc, elf.h
	  (installed via libelf on Linux) and err.h (installed via libbsd
	  on Linux)
	- check config.mk and, if needed, set compiler and flags to your liking
	- make

To build the examples:
	- Build dependencies: MIPSEL capable assembler, compiler and linker
	- cd examples
	- check config.mk and, if needed, set compiler and flags to your liking
	- make
		* It is possible to build individual programs by running
		  make PROGRAM_NAME, where PROGRAM_NAME is the program's file
		  name excluding the '.c'

EXAMPLES:
To run the simulator (from the repository's root directory):
	- ./psim /path/to/mipsel_object_file

If your program uses more than one processor (like most of the examples):
	- ./psim -c NPROC /path/to/program
By default, NPROC is 1.

If your program needs more memory:
	- ./psim -m MEMSZ_IN_BYTES /path/to/program
By default MEMSZ_IN_BYTES is 16777216 bytes (16 Mib).

TODO:
- Implement COP2 to have some transputer-like functionality.
- Multi-threaded simulation

NOTES:
if NDEBUG was not set when compiling (it is by default), files called
cpuXXXX_instrdump will be created when the program is executed. To check
these files a MIPSEL capable objdump(1) is needed:
	- objdump -b binary -m mips -EL -Mno-aliases -D cpuXXXX_instrdump

At the end of the simulation, a file called perfct will be created at the
current directory, containing a number of performance counters.

Although it can simulate multiple processors, the simulator itself runs on
a single thread. This makes easier to debug the examples (the simulation is
deterministic) at the cost of simulation speed.

Always remember to use the correct number of simulated processors while
running the examples, otherwise the simulation can hang forever.
